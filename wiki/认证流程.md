# 认证流程

本文档详细说明 Auth9 的认证和授权流程。

## 认证流程概览

Auth9 基于标准的 OIDC (OpenID Connect) 协议实现认证。

### 流程图

```
┌──────────┐          ┌──────────┐          ┌──────────┐          ┌──────────┐
│   用户   │          │ 业务服务  │          │  Auth9   │          │ Keycloak │
└────┬─────┘          └─────┬────┘          └─────┬────┘          └─────┬────┘
     │                      │                      │                      │
     │  1. 访问受保护资源    │                      │                      │
     │─────────────────────>│                      │                      │
     │                      │                      │                      │
     │  2. 重定向到认证页面  │                      │                      │
     │<─────────────────────│                      │                      │
     │                      │                      │                      │
     │  3. 访问 Auth9 登录页 │                      │                      │
     │──────────────────────┼─────────────────────>│                      │
     │                      │                      │                      │
     │  4. 重定向到 Keycloak │                      │                      │
     │<─────────────────────┼──────────────────────│                      │
     │                      │                      │                      │
     │  5. 输入凭证          │                      │                      │
     │──────────────────────┼──────────────────────┼─────────────────────>│
     │                      │                      │                      │
     │  6. 返回 Code        │                      │                      │
     │<─────────────────────┼──────────────────────┼──────────────────────│
     │                      │                      │                      │
     │  7. 回调业务服务      │                      │                      │
     │─────────────────────>│                      │                      │
     │                      │                      │                      │
     │                      │  8. Code 换 Token   │                      │
     │                      │─────────────────────>│  9. 验证 Code       │
     │                      │                      │─────────────────────>│
     │                      │                      │                      │
     │                      │  10. Identity Token  │  11. 返回 Token     │
     │                      │<─────────────────────│<─────────────────────│
     │                      │                      │                      │
     │  12. 访问成功         │                      │                      │
     │<─────────────────────│                      │                      │
```

## 1. 授权码流程 (Authorization Code Flow)

这是最常用也是最安全的认证流程。

### 步骤 1: 重定向到登录页面

用户访问受保护的资源时，应用重定向到 Auth9 授权端点。

**请求示例**：

```http
GET /auth/authorize?
    response_type=code&
    client_id=your-client-id&
    redirect_uri=https://your-app.com/callback&
    scope=openid profile email&
    state=random-state-value&
    nonce=random-nonce-value
```

**参数说明**：

| 参数 | 说明 | 必填 |
|------|------|------|
| response_type | 响应类型，固定为 `code` | ✅ |
| client_id | 服务的客户端 ID | ✅ |
| redirect_uri | 回调地址，必须与注册时一致 | ✅ |
| scope | 请求的权限范围 | ✅ |
| state | 防 CSRF 攻击的随机值 | ✅ |
| nonce | 防重放攻击的随机值 | 推荐 |

### 步骤 2: 用户登录

用户在 Keycloak 登录页面输入凭证：
- 用户名/邮箱
- 密码
- （可选）MFA 验证码

### 步骤 3: 授权确认

用户确认授权（首次登录时）：
- 查看应用请求的权限
- 同意或拒绝授权

### 步骤 4: 返回授权码

认证成功后，重定向回应用并携带授权码。

**回调示例**：

```
https://your-app.com/callback?
    code=auth-code-value&
    state=random-state-value
```

**注意事项**：
- 验证 state 参数与请求时一致
- 授权码有效期很短（通常 60 秒）
- 授权码只能使用一次

### 步骤 5: 交换 Token

应用后端使用授权码交换 Token。

**请求示例**：

```bash
curl -X POST https://auth9.yourdomain.com/auth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=authorization_code" \
  -d "code=auth-code-value" \
  -d "redirect_uri=https://your-app.com/callback" \
  -d "client_id=your-client-id" \
  -d "client_secret=your-client-secret"
```

**响应示例**：

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "refresh-token-value",
  "id_token": "eyJhbGciOiJIUzI1NiIs...",
  "scope": "openid profile email"
}
```

## 2. Token 交换流程

获得 Identity Token 后，需要交换特定租户的访问令牌。

### 步骤 1: gRPC 调用

```rust
use auth9::token_exchange_client::TokenExchangeClient;
use auth9::ExchangeTokenRequest;

let mut client = TokenExchangeClient::connect("http://auth9-core:50051").await?;

let request = ExchangeTokenRequest {
    identity_token: user_identity_token,
    tenant_id: "target-tenant-uuid".to_string(),
    service_client_id: "my-service".to_string(),
    scopes: vec!["read".to_string(), "write".to_string()],
};

let response = client.exchange_token(request).await?;
let access_token = response.into_inner().access_token;
```

### 步骤 2: 验证和缓存

Auth9 执行以下操作：

1. **验证 Identity Token**
   - 检查签名
   - 验证过期时间
   - 验证 Issuer

2. **查询用户权限**
   - 从缓存或数据库查询用户在租户中的角色
   - 计算有效权限（包括角色继承）

3. **生成 Access Token**
   - 创建包含租户和角色信息的新 Token
   - 设置适当的 Audience

4. **缓存结果**
   - 缓存用户角色信息
   - 设置 TTL

### 步骤 3: 使用 Access Token

```bash
curl https://api.your-service.com/api/resource \
  -H "Authorization: Bearer <tenant-access-token>"
```

## 3. Refresh Token 流程

当 Access Token 过期时，使用 Refresh Token 获取新的 Token。

### 请求示例

```bash
curl -X POST https://auth9.yourdomain.com/auth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=refresh_token" \
  -d "refresh_token=your-refresh-token" \
  -d "client_id=your-client-id" \
  -d "client_secret=your-client-secret"
```

### 响应示例

```json
{
  "access_token": "new-access-token",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "new-refresh-token",
  "scope": "openid profile email"
}
```

### Token 轮转

Auth9 实现 Refresh Token 轮转（Rotation）：
- 每次刷新都会返回新的 Refresh Token
- 旧的 Refresh Token 立即失效
- 增强安全性，防止 Token 被窃取

## 4. 客户端凭证流程

用于服务到服务的认证，无需用户参与。

### 请求示例

```bash
curl -X POST https://auth9.yourdomain.com/auth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=client_credentials" \
  -d "client_id=your-client-id" \
  -d "client_secret=your-client-secret" \
  -d "scope=service:read service:write"
```

### 响应示例

```json
{
  "access_token": "service-access-token",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "service:read service:write"
}
```

### 使用场景

- 后台任务
- 定时作业
- 服务间通信
- API 集成

## 5. 登出流程

### 单点登出 (Single Logout)

```bash
curl -X POST https://auth9.yourdomain.com/auth/logout \
  -H "Authorization: Bearer <access-token>" \
  -d "refresh_token=<refresh-token>"
```

执行操作：
1. 撤销 Access Token
2. 撤销 Refresh Token
3. 清除 Session
4. 清除缓存
5. 通知 Keycloak 登出

### 前端重定向登出

```http
GET https://auth9.yourdomain.com/auth/logout?
    post_logout_redirect_uri=https://your-app.com/goodbye&
    id_token_hint=<id-token>
```

## 集成示例

### Web 应用（React）

```typescript
import { AuthProvider, useAuth } from './auth';

function App() {
  return (
    <AuthProvider
      domain="auth9.yourdomain.com"
      clientId="your-client-id"
      redirectUri={window.location.origin + '/callback'}
    >
      <MyApp />
    </AuthProvider>
  );
}

function ProtectedPage() {
  const { isAuthenticated, login, user } = useAuth();

  if (!isAuthenticated) {
    return <button onClick={login}>登录</button>;
  }

  return <div>欢迎, {user.name}!</div>;
}
```

### 后端 API（Rust）

```rust
use axum::{
    routing::get,
    extract::State,
    http::Request,
    middleware::Next,
    response::Response,
};

async fn auth_middleware(
    State(jwt_service): State<JwtService>,
    req: Request,
    next: Next,
) -> Result<Response, AuthError> {
    // 从 Header 提取 Token
    let token = extract_token(&req)?;
    
    // 验证 Token
    let claims = jwt_service.validate(&token).await?;
    
    // 检查权限
    if !claims.has_permission("resource:read") {
        return Err(AuthError::Forbidden);
    }
    
    // 传递给下一个处理器
    Ok(next.run(req).await)
}
```

### 移动应用（iOS）

```swift
import Auth9SDK

class AuthManager {
    let auth9 = Auth9Client(
        domain: "auth9.yourdomain.com",
        clientId: "your-client-id"
    )
    
    func login() async throws {
        let credentials = try await auth9
            .webAuth()
            .start()
        
        // 保存 Token
        try KeychainWrapper.standard.set(
            credentials.accessToken,
            forKey: "access_token"
        )
    }
    
    func exchangeToken(tenantId: String) async throws -> String {
        let identityToken = KeychainWrapper.standard.string(forKey: "access_token")!
        
        let response = try await auth9
            .tokenExchange()
            .exchange(
                identityToken: identityToken,
                tenantId: tenantId,
                serviceClientId: "mobile-app"
            )
        
        return response.accessToken
    }
}
```

## 安全考虑

### 1. PKCE（Proof Key for Code Exchange）

对于公共客户端（如 SPA、移动应用），建议使用 PKCE。

```javascript
// 1. 生成 code_verifier
const codeVerifier = generateRandomString(64);

// 2. 生成 code_challenge
const codeChallenge = base64UrlEncode(sha256(codeVerifier));

// 3. 授权请求
const authUrl = `https://auth9.yourdomain.com/auth/authorize?
    response_type=code&
    client_id=${clientId}&
    redirect_uri=${redirectUri}&
    code_challenge=${codeChallenge}&
    code_challenge_method=S256`;

// 4. Token 交换时提供 code_verifier
const token = await exchangeToken(code, codeVerifier);
```

### 2. State 参数

防止 CSRF 攻击：

```javascript
// 生成随机 state
const state = generateRandomString(32);
sessionStorage.setItem('oauth_state', state);

// 授权请求包含 state
const authUrl = `...&state=${state}`;

// 回调时验证 state
const callbackState = new URLSearchParams(window.location.search).get('state');
if (callbackState !== sessionStorage.getItem('oauth_state')) {
    throw new Error('Invalid state parameter');
}
```

### 3. Nonce 参数

防止重放攻击：

```javascript
// 生成 nonce
const nonce = generateRandomString(32);
sessionStorage.setItem('oauth_nonce', nonce);

// 授权请求包含 nonce
const authUrl = `...&nonce=${nonce}`;

// 验证 ID Token 中的 nonce
const idToken = parseJWT(response.id_token);
if (idToken.nonce !== sessionStorage.getItem('oauth_nonce')) {
    throw new Error('Invalid nonce');
}
```

## 错误处理

### 常见错误

| 错误代码 | 说明 | 处理方式 |
|---------|------|---------|
| `invalid_request` | 请求参数错误 | 检查参数 |
| `unauthorized_client` | 客户端未授权 | 检查 client_id |
| `access_denied` | 用户拒绝授权 | 提示用户 |
| `invalid_grant` | 授权码无效或过期 | 重新认证 |
| `invalid_token` | Token 无效 | 刷新或重新登录 |

### 错误响应示例

```json
{
  "error": "invalid_grant",
  "error_description": "The authorization code is invalid or has expired",
  "error_uri": "https://docs.auth9.dev/errors#invalid_grant"
}
```

## 性能优化

### 1. Token 缓存

```rust
// 缓存 Token 验证结果
let cache_key = format!("token:{}:valid", token_hash);
if let Some(claims) = redis.get(&cache_key).await? {
    return Ok(claims);
}

let claims = validate_token(token).await?;
redis.set_ex(&cache_key, &claims, 300).await?; // 5 分钟
Ok(claims)
```

### 2. 连接复用

```rust
// 复用 gRPC 连接
lazy_static! {
    static ref TOKEN_EXCHANGE_CLIENT: TokenExchangeClient = {
        TokenExchangeClient::connect("http://auth9-core:50051")
            .await
            .expect("Failed to connect to Auth9")
    };
}
```

### 3. 批量验证

```rust
// 批量验证 Token
async fn validate_tokens_batch(tokens: Vec<String>) -> Result<Vec<Claims>> {
    let futures = tokens.iter().map(|token| validate_token(token));
    let results = join_all(futures).await;
    results.into_iter().collect()
}
```

## 相关文档

- [Token 规范](Token规范.md)
- [REST API](REST-API.md)
- [gRPC API](gRPC-API.md)
- [最佳实践](最佳实践.md)
